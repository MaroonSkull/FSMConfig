# AGENTS.md

## Оглавление

1. [Общая информация о проекте](#общая-информация-о-проекте)
2. [Используемые технологии](#используемые-технологии)
3. [Общие указания по работе](#общие-указания-по-работе)
4. [Документирование кода](#документирование-кода)
5. [Git workflow](#git-workflow)
6. [Критический подход к разработке](#критический-подход-к-разработке)

---

## Общая информация о проекте

### Назначение

**FSMConfig** — это C++ библиотека для работы с конечными автоматами (Finite State Machine) через YAML-конфигурацию. Библиотека позволяет декларативно описывать состояния, переходы, события и коллбэки в YAML-файлах, что упрощает создание и модификацию сложных автоматов состояний без необходимости перекомпиляции кода.

### Основные компоненты

#### Заголовочные файлы (`include/fsmconfig/`)

| Файл | Назначение |
|------|------------|
| [`state_machine.hpp`](include/fsmconfig/state_machine.hpp) | Основной класс конечного автомата |
| [`state.hpp`](include/fsmconfig/state.hpp) | Класс представления состояния |
| [`config_parser.hpp`](include/fsmconfig/config_parser.hpp) | Парсер YAML-конфигураций |
| [`event_dispatcher.hpp`](include/fsmconfig/event_dispatcher.hpp) | Диспетчер событий |
| [`callback_registry.hpp`](include/fsmconfig/callback_registry.hpp) | Реестр коллбэков |
| [`variable_manager.hpp`](include/fsmconfig/variable_manager.hpp) | Менеджер переменных |
| [`types.hpp`](include/fsmconfig/types.hpp) | Основные типы и определения |

#### Исходные файлы (`src/fsmconfig/`)

| Файл | Реализация |
|------|------------|
| [`state_machine.cpp`](src/fsmconfig/state_machine.cpp) | Логика работы конечного автомата |
| [`state.cpp`](src/fsmconfig/state.cpp) | Управление состояниями |
| [`config_parser.cpp`](src/fsmconfig/config_parser.cpp) | Парсинг YAML |
| [`event_dispatcher.cpp`](src/fsmconfig/event_dispatcher.cpp) | Обработка событий |
| [`callback_registry.cpp`](src/fsmconfig/callback_registry.cpp) | Регистрация и вызов коллбэков |
| [`variable_manager.cpp`](src/fsmconfig/variable_manager.cpp) | Управление переменными |
| [`types.cpp`](src/fsmconfig/types.cpp) | Вспомогательные типы |

#### Тесты (`tests/`)

- [`test_state_machine.cpp`](tests/test_state_machine.cpp) — тесты конечного автомата
- [`test_config_parser.cpp`](tests/test_config_parser.cpp) — тесты парсера конфигурации
- [`test_callback_registry.cpp`](tests/test_callback_registry.cpp) — тесты реестра коллбэков
- [`test_integration.cpp`](tests/test_integration.cpp) — интеграционные тесты

#### Примеры (`examples/`)

- [`simple_fsm/`](examples/simple_fsm/) — простой пример конечного автомата
- [`game_state/`](examples/game_state/) — пример управления состояниями игры
- [`network_protocol/`](examples/network_protocol/) — пример протокола сетевого взаимодействия

#### Дополнительные файлы конфигурации

| Файл/Директория | Назначение |
|-----------------|------------|
| [`cmake/Findyaml-cpp.cmake`](cmake/Findyaml-cpp.cmake) | Кастомный модуль поиска yaml-cpp |
| [`cmake/fsmconfig-config.cmake.in`](cmake/fsmconfig-config.cmake.in) | Шаблон конфигурации CMake |
| [`Dockerfile`](Dockerfile) | Docker-образ для разработки |
| [`.devcontainer/`](.devcontainer/) | Конфигурация VS Code Dev Container |
| [`.github/`](.github/) | Конфигурация GitHub Actions |
| [`.gitignore`](.gitignore) | Правила исключения Git |
| [`LICENSE`](LICENSE) | Лицензия проекта |

---

## Используемые технологии

### C++ стандарт и особенности

- **Стандарт:** C++20
- **Компилятор:** GCC/Clang с поддержкой C++20
- **Особенности:**
  - Использование RAII для управления ресурсами
  - Smart pointers (`std::unique_ptr`, `std::shared_ptr`)
  - STL контейнеры и алгоритмы
  - Lambda-выражения для коллбэков
  - `std::function` и `std::bind` для обратных вызовов

### CMake конфигурация

- **Минимальная версия:** CMake 3.15+
- **Система сборки:** Современный CMake с использованием target-based подхода
- **Основные цели:**
  - `fsmconfig` — основная библиотека
  - `fsmconfig_tests` — тесты
  - `simple_fsm`, `game_state`, `network_protocol` — примеры использования

**Пример сборки:**

```bash
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build .
```

### yaml-cpp

- **Версия:** 0.7.0 или выше
- **Назначение:** Парсинг YAML-конфигураций
- **Интеграция:** Через CMake с тремя fallback-методами:
  1. `find_package(yaml-cpp CONFIG)` для системных пакетов
  2. `pkg_check_modules(yaml-cpp)` через PkgConfig (для Arch Linux)
  3. Кастомный модуль [`cmake/Findyaml-cpp.cmake`](cmake/Findyaml-cpp.cmake) как последний вариант

**Пример конфигурации:**

```yaml
# Глобальные переменные
variables:
  max_attempts: 3

# Определения состояний
states:
  idle:
    on_enter: on_idle_enter
    on_exit: on_idle_exit
    actions:
      - log_idle_state
  
  active:
    on_enter: on_active_enter
    on_exit: on_active_exit
    actions:
      - log_active_state

# Определения переходов
transitions:
  - from: idle
    to: active
    event: start
    on_transition: on_start_transition
  
  - from: active
    to: idle
    event: stop
    on_transition: on_stop_transition
```

### Система тестирования

- **Фреймворк:** Google Test (gtest)
- **Запуск тестов:**
  ```bash
  cd build
  ctest --output-on-failure
  ```
- **Покрытие:** Юнит-тесты для каждого компонента + интеграционные тесты

### Линтеры и инструменты качества кода

| Инструмент | Назначение |
|------------|------------|
| **clangd** | Language Server Protocol для C++ |
| **clang-tidy** | Статический анализ кода |
| **clang-format** | Форматирование кода |
| **cppcheck** | Дополнительный статический анализ |
| **include-what-you-use** | Анализ включаемых заголовков |

**Рекомендуемые проверки clang-tidy:**

```bash
clang-tidy src/**/*.cpp -- -Iinclude/ -std=c++20
```

### Конфигурационные файлы линтеров

Для правильной работы линтеров необходимо создать конфигурационные файлы в корневой директории проекта:

#### .clang-tidy
```yaml
Checks: >
  -*,
  bugprone-*,
  -bugprone-easily-swappable-parameters,
  cert-*,
  clang-analyzer-*,
  cppcoreguidelines-*,
  -cppcoreguidelines-avoid-magic-numbers,
  -cppcoreguidelines-pro-bounds-pointer-arithmetic,
  -cppcoreguidelines-pro-type-reinterpret-cast,
  modernize-*,
  -modernize-use-trailing-return-type,
  performance-*,
  readability-*,
  -readability-magic-numbers,
  -readability-identifier-length
WarningsAsErrors: ''
HeaderFilterRegex: '.*'
FormatStyle: file
```

#### .clang-format
```yaml
BasedOnStyle: Google
IndentWidth: 4
ColumnLimit: 100
```

#### .cppcheck
```ini
--enable=all
--inconclusive
--std=c++20
-Iinclude/
```

**Важно:** Эти файлы должны быть созданы перед первым запуском линтеров.

---

## Общие указания по работе

### ВАЖНО: Использование контекста

Для эффективной работы с проектом ВСЕГДА использовать:

1. **"use context7"** — для получения контекста о текущем состоянии проекта
2. **"Knowledge Graph Memory"** — для сохранения и извлечения знаний о проекте

### Пайплайн выполнения высокоуровневых задач

```
1. Сделать маленькое действие
   ↓
2. Критически проанализировать результаты
   (используя режимы code-skeptic, code-reviewer)
   ↓
3. Если есть ошибки или недоработки:
   ├─ Подготовить вопрос пользователю для уточнения
   └─ Вернуться к пункту 1 и переработать решение
   ↓
4. Если ошибок нет — двигаться по задаче дальше
```

### Стратегия разбиения задач на подзадачи

**Принцип:** Критические и сложные задачи должны разбиваться на множество мелких, независимых подзадач.

**Зачем это нужно:**

1. **Уменьшение контекстной нагрузки:**
   - Нейросети имеют ограниченный размер контекста
   - Меньшие задачи требуют меньше контекста
   - Это повышает качество выполнения каждой подзадачи

2. **Подготовка к параллельному выполнению:**
   - Мелкие независимые задачи можно выполнять параллельно
   - Это ускоряет общее время выполнения
   - В будущем будет реализована поддержка параллельного вызова агентов

**Как разбивать задачи:**

**Правило 1: Одна задача — одна конкретная цель**
- ❌ Плохо: "Проанализировать весь проект и исправить все проблемы"
- ✅ Хорошо: "Проверить соответствие C++ стандарта в CMakeLists.txt"

**Правило 2: Задача должна быть завершённой**
- Каждая подзадача должна иметь чёткий критерий завершения
- Результат подзадачи должен быть самостоятельно полезен

**Правило 3: Минимизировать зависимости между подзадачами**
- Подзадачи должны быть как можно более независимыми
- Если подзадача B зависит от подзадачи A, они должны выполняться последовательно

**Примеры разбиения:**

**Пример 1: Критический анализ документации**
Вместо одной большой задачи "Проанализировать AGENTS.md":
- ✅ Подзадача 1: "Проверить соответствие C++ стандарта"
- ✅ Подзадача 2: "Проверить формат YAML конфигурации"
- ✅ Подзадача 3: "Проверить наличие конфигурационных файлов линтеров"
- ✅ Подзадача 4: "Проверить соответствие структуры файлов"

**Пример 2: Рефакторинг кода**
Вместо "Рефакторить все классы проекта":
- ✅ Подзадача 1: "Рефакторить класс StateMachine"
- ✅ Подзадача 2: "Рефакторить класс ConfigParser"
- ✅ Подзадача 3: "Рефакторить класс EventDispatcher"

**Пример 3: Добавление документации**
Вместо "Задокументировать весь проект":
- ✅ Подзадача 1: "Задокументировать методы StateMachine"
- ✅ Подзадача 2: "Задокументировать методы ConfigParser"
- ✅ Подзадача 3: "Задокументировать методы EventDispatcher"

**Когда НЕ стоит разбивать:**

- Если задача тривиальная и занимает менее 2-3 минут
- Если разбиение создаст больше сложностей, чем решит
- Если подзадачи будут сильно зависеть друг от друга

**Практические рекомендации:**

1. **Ориентир на время:** Идеальная подзадача занимает 5-15 минут
2. **Ориентир на контекст:** Подзадача должна использовать не более 20-30% доступного контекста
3. **Ориентир на результат:** Каждая подзадача должна давать конкретный измеримый результат

**Для orchestrator режима:**

При делегировании задач:
1. Анализировать сложность задачи
2. Если задача сложная — разбивать на подзадачи
3. Создавать отдельные подзадачи для разных аспектов
4. Координировать выполнение подзадач
5. Собирать результаты в единое целое

### Процесс решения высокоуровневой задачи

```
1. Создать архитектурные ADR
   └─ Расположение: docs/architecture/decisions/
   └─ **Важно:** Директория должна быть создана перед использованием
   ↓
2. Добавить диаграммы
   ├─ Диаграммы компонентов
   └─ Data flow диаграммы
   ↓
3. Документировать каждый критический path
   ↓
4. Провести аудит кода на основе документов
   ├─ Найти дублирование (DRY)
   ├─ Найти неправильную логику
   └─ Найти расхождения с архитектурным планом
```

**Пример структуры ADR:**

```markdown
# ADR-001: Выбор подхода для управления состоянием

## Статус
Предложено

## Контекст
Необходимо определить способ управления переходами между состояниями...

## Решение
Использовать паттерн State с делегированием управления...

## Последствия
Плюсы: ...
Минусы: ...
```

### Использование линтеров

**Принцип:** Использовать максимально широкий набор линтеров для обеспечения высокого качества кода.

**Обязательные проверки:**

```bash
# clang-tidy с современными проверками
clang-tidy src/**/*.cpp \
  --checks='*' \
  -warnings-as-errors='*' \
  -- -Iinclude/ -std=c++20

# cppcheck для дополнительного анализа
cppcheck --enable=all --inconclusive --std=c++20 src/

# clang-format для форматирования
clang-format -i src/**/*.cpp include/**/*.hpp
```

### Поиск библиотек

**Философия:** Не изобретать велосипед — искать готовые решения.

**Процесс:**

1. При необходимости новой функциональности — сначала поиск в интернете (tavily)
2. Цель: создать простой код, используя существующие библиотеки
3. Не бояться обилия зависимостей
4. При разработке НЕ реализовывать новые методы самостоятельно
5. Если найдена подходящая библиотека:
   - Предложить пользователю её интеграцию
   - Дождаться ответа
   - Только после одобрения — интегрировать

**Примеры поиска:**
- Для работы с JSON → `nlohmann/json`
- Для логирования → `spdlog`
- Для тестирования → `Catch2` или `gtest`
- Для работы с временем → `date` (Howard Hinnant)

---

## Документирование кода

### Общие правила

- **Язык документации:** Русский

**Примечание:** Технические термины, названия команд, библиотек и стандартов оставляются на английском языке (например, RAII, smart pointers, `std::unique_ptr`, C++20). Код и команды всегда на английском.

- **Упоминания кода:** Обрамлять обратным апострофом (\`)
- **Формат Doxygen:** Java стиль (`/** @... */`)

### Однострочные комментарии

```cpp
/// Регистрирует новый коллбэк для указанного события
void registerCallback(const std::string& event, CallbackFunc callback);
```

**Важно:** Комментарий `///` всегда должен находиться ПЕРЕД комментируемым элементом.

### Многострочные комментарии

```cpp
/**
 * @brief Парсит YAML-конфигурацию и создаёт конечный автомат
 * 
 * @param config_path Путь к YAML-файлу с конфигурацией
 * @return std::unique_ptr<StateMachine> Указатель на созданный автомат
 * @throws std::runtime_error Если конфигурация некорректна
 * 
 * @example
 * auto fsm = parser.parseConfig("config.yaml");
 * fsm->start();
 */
std::unique_ptr<StateMachine> parseConfig(const std::string& config_path);
```

### Содержание комментариев

**Описывать бизнес-логику, а не алгоритм:**

✅ **Плохо:**
```cpp
/// Проходим по всем элементам массива и проверяем условие
void processEvents();
```

❌ **Хорошо:**
```cpp
/// Обрабатывает все события из очереди в порядке их поступления
/// и выполняет соответствующие переходы состояний
void processEvents();
```

### Обязательность документирования

Документировать ВСЕ функции, которые затрагиваются в ходе работы:

- Публичные методы классов
- Защищённые методы (если они являются частью API)
- Приватные методы (если они содержат нетривиальную логику)
- Функции свободного доступа
- Структуры и классы
- Перечисления

---

## Git workflow (Trunk-Based Development)

### Общий процесс

```
1. Кратко проанализировать задачу (режим orchestrator)
   ↓
2. Придумать название задачи
   ↓
3. Создать новую ветку для задачи
   ↓
4. Для отдельных подзадач создавать дополнительные ветки
   ↓
5. После завершения подзадачи — смерджить в рабочую ветку
```

### Создание веток

**Формат названия веток:**

```
feature/краткое-описание-задачи
bugfix/описание-бага
refactor/описание-рефакторинга
docs/описание-документации
```

**Примеры:**

```bash
git checkout -b feature/add-state-persistence
git checkout -b bugfix/fix-memory-leak-in-parser
git checkout -b refactor/optimize-event-dispatcher
```

### Коммиты

**Правила коммитов:**

1. **Частота:** Делать коммиты так часто, как только возможно
2. **История:** История коммитов должна быть богатой и информативной
3. **ПРАВИЛО:** Перед созданием коммита убедиться:
   - Код работает корректно ИЛИ
   - Код как минимум компилируется без ошибок

**Формат сообщения коммита:**

```
<тип>: <краткое описание>

<подробное описание (опционально)>

<ссылки на задачи (опционально)>
```

**Типы коммитов:**

- `feat` — новая функциональность
- `fix` — исправление бага
- `refactor` — рефакторинг
- `docs` — документация
- `test` — тесты
- `chore` — рутинные задачи

**Примеры:**

```
feat: добавить поддержку вложенных состояний

Реализована иерархическая структура состояний с наследованием.
Добавлены тесты в test_state_machine.cpp.

Closes #42
```

```
fix: исправить утечку памяти в ConfigParser

Проблема была в отсутствии освобождения YAML::Node.
Теперь используется умный указатель.
```

### Завершение задачи

```
1. Критический анализ git diff
   └─ Использовать режим review
   ↓
2. Проверка документации
   └─ Все затронутые места задокументированы?
   ↓
3. Слияние веток
   └─ Смерджить все дополнительные ветки в основную рабочую
   ↓
4. Рабочую ветку никуда сливать не нужно
   └─ Её анализ выполнит программист
```

**Процесс review:**

```bash
# Показать все изменения
git diff main..feature/branch-name

# Интерактивный review
git review main..feature/branch-name
```

---

## Критический подход к разработке

### Философия

**Сомневаться в каждом решении**

- Каждое решение должно быть обоснованным
- Соотносить решения с существующими частями системы
- Соотносить с чужими решениями за пределами кодовой базы
- Находить ошибки в планах и итеративно их устранять

### Цикл разработки

```
Немного подумала
   ↓
Покритиковала
   ↓
Переделала
   ↓
Снова покритиковала
   ↓
Снова переделала
   ↓
(Повторять пока не перестанет находить ошибки)
   ↓
Плавная интеграция в код
```

### При интеграции

**Перепроверять кодовую базу:**

1. **DRY (Don't Repeat Yourself)**
   - Поиск дублирующего кода
   - Вынесение общих частей в отдельные функции/классы

2. **Поиск готовых элементов**
   - Проверить, не существует ли уже нужная функциональность
   - Использовать существующие утилиты и хелперы

3. **Поиск готовых библиотек в интернете**
   - Использовать tavily для поиска
   - Найти 2-3 альтернативы
   - Предложить пользователю интеграцию
   - Дождаться ответа

### Пример критического анализа

**Вопросы к себе:**

1. Почему именно это решение?
2. Есть ли более простой способ?
3. Не нарушает ли это существующие паттерны?
4. Не создаст ли это проблемы в будущем?
5. Существуют ли готовые библиотеки для этой задачи?
6. Не дублирую ли я существующий код?
7. Покроют ли тесты это изменение?
8. Достаточно ли документировано это изменение?

### Инструменты для критического анализа

| Режим | Назначение |
|-------|------------|
| **code-skeptic** | Критический анализ кода на наличие проблем |
| **code-reviewer** | Тщательный review изменений |
| **code-simplifier** | Поиск возможностей для упрощения |
| **debug** | Анализ потенциальных проблем |

---

## Дополнительные ресурсы

### Внутренняя документация

- [`README.md`](README.md) — общее описание проекта
- [`DOCKER.md`](DOCKER.md) — инструкции по работе с Docker
- [`docs/architecture.md`](docs/architecture.md) — архитектура проекта
- [`docs/api_reference.md`](docs/api_reference.md) — справочник по API
- [`docs/examples.md`](docs/examples.md) — примеры использования

### Внешние ресурсы

- [CMake Documentation](https://cmake.org/documentation/)
- [yaml-cpp Documentation](https://github.com/jbeder/yaml-cpp/)
- [Google Test Documentation](https://google.github.io/googletest/)
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/)

---

## Краткая шпаргалка

### Быстрый старт

```bash
# Сборка проекта
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build .

# Запуск тестов
ctest --output-on-failure

# Запуск линтеров
clang-tidy src/**/*.cpp -- -Iinclude/ -std=c++20
clang-format -i src/**/*.cpp include/**/*.hpp
```

### Типичный workflow

```bash
# 1. Создать ветку
git checkout -b feature/my-feature

# 2. Внести изменения
# ... код ...

# 3. Проверить линтерами
clang-tidy src/**/*.cpp -- -Iinclude/ -std=c++20

# 4. Запустить тесты
cd build && ctest --output-on-failure

# 5. Закоммитить
git add .
git commit -m "feat: add my feature"

# 6. Повторить для подзадач
# ...

# 7. Review
git diff main..feature/my-feature

# 8. Смерджить подветки
git merge feature/sub-task-1
```

---

*Последнее обновление: 2026-01-31*
